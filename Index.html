<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Royal Match Style Game</title>
    
    <!-- Tailwind CSS (ìŠ¤íƒ€ì¼ë§) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (ë¦¬ì•¡íŠ¸ ì½”ì–´) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (JSX ë³€í™˜ìš©) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; }
        
        @keyframes pop {
          0% { transform: scale(0.8); opacity: 0; }
          100% { transform: scale(1); opacity: 1; }
        }
        
        .animate-pop {
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-white overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // --- ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ (Lucide ì•„ì´ì½˜ì„ SVGë¡œ ì§ì ‘ êµ¬í˜„í•˜ì—¬ ì˜ì¡´ì„± ì œê±°) ---
        const Crown = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"/></svg>
        );
        const Shield = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
        );
        const Sword = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" y1="19" x2="19" y2="13"/><line x1="16" y1="16" x2="20" y2="20"/><line x1="19" y1="21" x2="21" y2="19"/></svg>
        );
        const Gem = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></svg>
        );
        const Coins = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><circle cx="8" cy="8" r="6"/><path d="M18.09 10.37A6 6 0 1 1 10.34 18"/><path d="M7 6h1v4"/><path d="m16.71 13.88.7 .71-2.82 2.82"/></svg>
        );
        const Trophy = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
        );
        const RotateCcw = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 5v7h7"/></svg>
        );
        const Play = ({ size = 24, className = "", ...props }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><polygon points="5 3 19 12 5 21 5 3"/></svg>
        );

        // --- ê²Œìž„ ì„¤ì • ---
        const BOARD_SIZE = 8;
        const TYPES = ['crown', 'shield', 'sword', 'gem', 'coin', 'potion'];
        const TARGET_SCORE = 2000;
        const MAX_MOVES = 25;

        const IconsMap = {
            crown: { component: Crown, color: 'text-yellow-400', bg: 'bg-yellow-900/40' },
            shield: { component: Shield, color: 'text-slate-300', bg: 'bg-slate-700/40' },
            sword: { component: Sword, color: 'text-blue-400', bg: 'bg-blue-900/40' },
            gem: { component: Gem, color: 'text-pink-500', bg: 'bg-pink-900/40' },
            coin: { component: Coins, color: 'text-amber-500', bg: 'bg-amber-800/40' },
            potion: { component: Trophy, color: 'text-purple-400', bg: 'bg-purple-900/40' },
        };

        function App() {
            const [board, setBoard] = useState([]);
            const [selected, setSelected] = useState(null);
            const [score, setScore] = useState(0);
            const [moves, setMoves] = useState(MAX_MOVES);
            const [gameState, setGameState] = useState('start'); 
            const [isProcessing, setIsProcessing] = useState(false);

            const getRandomType = () => TYPES[Math.floor(Math.random() * TYPES.length)];

            const initGame = useCallback(() => {
                const newBoard = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        row.push({ type: getRandomType(), id: `r${r}-c${c}-${Date.now()}-${Math.random()}` });
                    }
                    newBoard.push(row);
                }
                setBoard(newBoard);
                setScore(0);
                setMoves(MAX_MOVES);
                setGameState('playing');
                setIsProcessing(false);
                setSelected(null);
            }, []);

            // ë³´ë“œ ì´ˆê¸°í™” (ì²« ì‹¤í–‰ ì‹œ)
            useEffect(() => {
                if (board.length === 0) initGame();
            }, []);

            const checkMatches = (currentBoard) => {
                const matched = new Set();
                
                // ê°€ë¡œ
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE - 2; c++) {
                        const type = currentBoard[r][c]?.type;
                        if (!type) continue;
                        if (currentBoard[r][c + 1]?.type === type && currentBoard[r][c + 2]?.type === type) {
                            matched.add(`${r},${c}`);
                            matched.add(`${r},${c + 1}`);
                            matched.add(`${r},${c + 2}`);
                        }
                    }
                }
                // ì„¸ë¡œ
                for (let r = 0; r < BOARD_SIZE - 2; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const type = currentBoard[r][c]?.type;
                        if (!type) continue;
                        if (currentBoard[r + 1][c]?.type === type && currentBoard[r + 2][c]?.type === type) {
                            matched.add(`${r},${c}`);
                            matched.add(`${r + 1},${c}`);
                            matched.add(`${r + 2},${c}`);
                        }
                    }
                }
                return Array.from(matched).map(str => {
                    const [r, c] = str.split(',').map(Number);
                    return { r, c };
                });
            };

            useEffect(() => {
                if (gameState !== 'playing') return;

                const processBoard = async () => {
                    const matches = checkMatches(board);

                    if (matches.length > 0) {
                        setIsProcessing(true);
                        setScore(prev => prev + matches.length * 10);

                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        const newBoard = board.map(row => row.map(cell => ({ ...cell })));
                        matches.forEach(({ r, c }) => {
                            newBoard[r][c] = null; 
                        });
                        setBoard(newBoard);

                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        const gravityBoard = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
                        
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            let writeRow = BOARD_SIZE - 1;
                            for (let r = BOARD_SIZE - 1; r >= 0; r--) {
                                if (newBoard[r][c]) {
                                    gravityBoard[writeRow][c] = newBoard[r][c];
                                    writeRow--;
                                }
                            }
                            for (let r = writeRow; r >= 0; r--) {
                                gravityBoard[r][c] = { 
                                    type: getRandomType(), 
                                    id: `new-${Date.now()}-${r}-${c}-${Math.random()}` 
                                };
                            }
                        }
                        setBoard(gravityBoard);
                    } else {
                        setIsProcessing(false);
                        if (moves <= 0 && score < TARGET_SCORE) {
                            setGameState('lost');
                        } else if (score >= TARGET_SCORE) {
                            setGameState('won');
                        } else if (moves <= 0) {
                            setGameState('won');
                        }
                    }
                };

                if (board.length > 0) {
                    const timer = setTimeout(processBoard, 200);
                    return () => clearTimeout(timer);
                }
            }, [board, gameState, moves]);

            const handleTileClick = (r, c) => {
                if (gameState !== 'playing' || isProcessing) return;

                if (!selected) {
                    setSelected({ r, c });
                } else {
                    if (selected.r === r && selected.c === c) {
                        setSelected(null);
                        return;
                    }
                    const isAdjacent = Math.abs(selected.r - r) + Math.abs(selected.c - c) === 1;
                    if (isAdjacent) {
                        attemptSwap(selected, { r, c });
                        setSelected(null);
                    } else {
                        setSelected({ r, c });
                    }
                }
            };

            const attemptSwap = async (pos1, pos2) => {
                setIsProcessing(true);
                const tempBoard = board.map(row => row.map(cell => ({ ...cell })));
                const temp = tempBoard[pos1.r][pos1.c];
                tempBoard[pos1.r][pos1.c] = tempBoard[pos2.r][pos2.c];
                tempBoard[pos2.r][pos2.c] = temp;

                setBoard(tempBoard); 

                const matches = checkMatches(tempBoard);
                if (matches.length > 0) {
                    setMoves(prev => prev - 1);
                } else {
                    await new Promise(resolve => setTimeout(resolve, 400));
                    setBoard(board); 
                    setIsProcessing(false);
                }
            };

            const getProgressWidth = () => Math.min(100, (score / TARGET_SCORE) * 100);

            return (
                <div className="min-h-screen bg-slate-900 flex flex-col items-center justify-center p-4 select-none relative">
                    <div className="absolute inset-0 bg-gradient-to-br from-blue-900 via-slate-900 to-slate-950 -z-10" />
                    
                    {/* Header */}
                    <div className="w-full max-w-md flex flex-col gap-4 mb-4 z-10">
                        <div className="flex justify-between items-center px-2">
                            <div className="bg-slate-800/80 rounded-xl px-4 py-2 border border-slate-600 flex flex-col items-center min-w-[80px]">
                                <span className="text-xs text-slate-400 uppercase font-bold tracking-wider">Moves</span>
                                <span className={`text-2xl font-black ${moves <= 5 ? 'text-red-500 animate-pulse' : 'text-white'}`}>{moves}</span>
                            </div>
                            
                            <div className="flex-1 mx-4 flex flex-col justify-center">
                                <div className="flex justify-between text-xs mb-1 font-bold text-yellow-500">
                                    <span>SCORE</span>
                                    <span>{score} / {TARGET_SCORE}</span>
                                </div>
                                <div className="h-4 bg-slate-800 rounded-full overflow-hidden border border-slate-700 relative">
                                    <div className="h-full bg-gradient-to-r from-yellow-600 to-yellow-400 transition-all duration-500 ease-out" style={{ width: `${getProgressWidth()}%` }} />
                                    <div className="absolute top-0 left-0 w-full h-1/2 bg-white/20" />
                                </div>
                            </div>

                            <button onClick={initGame} className="p-3 bg-blue-600 hover:bg-blue-500 rounded-xl shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all">
                                <RotateCcw size={20} className="text-white" />
                            </button>
                        </div>
                    </div>

                    {/* Game Board Area */}
                    <div className="relative bg-[#2c3e50] p-3 rounded-2xl shadow-2xl border-4 border-[#34495e] w-full max-w-md aspect-square z-10">
                        <div className="w-full h-full grid grid-cols-8 grid-rows-8 gap-1 bg-[#202c39] rounded-xl p-1 overflow-hidden relative">
                            {/* Start Screen */}
                            {gameState === 'start' && (
                                <div className="absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm rounded-xl">
                                    <h1 className="text-4xl font-black text-yellow-400 mb-2 drop-shadow-lg text-center">ROYAL<br/>PUZZLE</h1>
                                    <button onClick={initGame} className="mt-4 flex items-center gap-2 px-8 py-4 bg-green-500 hover:bg-green-400 text-white font-bold rounded-full shadow-lg border-b-4 border-green-700 active:border-b-0 active:translate-y-1 transition-all text-xl">
                                        <Play fill="currentColor" /> START
                                    </button>
                                </div>
                            )}

                            {/* Game Over / Win Screen */}
                            {(gameState === 'won' || gameState === 'lost') && (
                                <div className="absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/80 backdrop-blur-md rounded-xl animate-pop">
                                    {gameState === 'won' ? (
                                        <>
                                            <Trophy size={64} className="text-yellow-400 mb-4 animate-bounce" />
                                            <h2 className="text-4xl font-black text-white mb-2 text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 to-yellow-600">VICTORY!</h2>
                                        </>
                                    ) : (
                                        <>
                                            <div className="text-6xl mb-4">ðŸ˜¢</div>
                                            <h2 className="text-3xl font-black text-red-500 mb-2">FAILED</h2>
                                        </>
                                    )}
                                    <p className="text-slate-300 mb-6 font-bold">Score: {score}</p>
                                    <button onClick={initGame} className="px-8 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-full shadow-lg border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all">
                                        PLAY AGAIN
                                    </button>
                                </div>
                            )}

                            {/* Grid */}
                            {board.map((row, r) => (
                                row.map((cell, c) => {
                                    if (!cell) return <div key={`empty-${r}-${c}`} className="rounded-lg bg-slate-800/30" />;
                                    
                                    const IconData = IconsMap[cell.type];
                                    const IconComponent = IconData.component;
                                    const isSelected = selected?.r === r && selected?.c === c;
                                    
                                    return (
                                        <div
                                            key={cell.id}
                                            onClick={() => handleTileClick(r, c)}
                                            className={`
                                                relative rounded-lg flex items-center justify-center cursor-pointer transition-all duration-200
                                                ${IconData.bg}
                                                ${isSelected ? 'ring-2 ring-white z-20 scale-110 brightness-125' : 'hover:brightness-110'}
                                                ${gameState !== 'playing' ? 'opacity-50' : 'opacity-100'}
                                            `}
                                        >
                                            <IconComponent 
                                                size={24} 
                                                className={`${IconData.color} drop-shadow-md`} 
                                                strokeWidth={2.5}
                                            />
                                        </div>
                                    );
                                })
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

